// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------

using UnityEngine;
using System.Collections.Generic;
using System.Linq;

namespace Sculpt
{
	public class Topology
	{

		List<Vertex> vertices = null;
		List<Triangle> triangles = null;

		SculptMesh mesh;


		//
		List<Vector3> vertexList = null;
		List<Vector3> normalList = null;
		List<Color> colorList = null;
		List<int> indexList = null;



		int[] indexArray = null;
		Dictionary<uint,int> newVectices = null;//to detect new vertices at the middle of edge (for subdivision)

		public Topology (SculptMesh mesh)
		{
			this.mesh = mesh;
			this.vertices = mesh.vertices;
			this.triangles = mesh.triangles;
			this.vertexList = new List<Vector3>(mesh.vertexArray);
			this.normalList = new List<Vector3>(mesh.normalArray);
			this.colorList = new List<Color>(mesh.colorArray);
			this.indexList = new List<int>(mesh.indexArray);
			this.indexArray = mesh.indexArray;

			this.newVectices = new Dictionary<uint,int>();

		}

		public List<int> Subdivision(List<int> iTris, float detailMaxSquared){
			newVectices.Clear();


			int nbTriangles = iTris.Count;
			for(int i = 0; i < nbTriangles; i++){

				int triIdx = iTris[i] * 3;
				int iVert1 = indexArray[triIdx + 0];
				int iVert2 = indexArray[triIdx + 1];
				int iVert3 = indexArray[triIdx + 2];

				Vector3 v1 = mesh.transform.InverseTransformPoint(vertexList[iVert1]);
				Vector3 v2 = mesh.transform.InverseTransformPoint(vertexList[iVert2]);
				Vector3 v3 = mesh.transform.InverseTransformPoint(vertexList[iVert3]);

				if(Vector3.Distance(v1, v2) > detailMaxSquared || Vector3.Distance(v1, v3) > detailMaxSquared)
				{
					Subdivide4Triangle(iTris[i]);

					// flick holes...

				}
			}

			mesh.vertexArray = vertexList.ToArray();
			if (normalList.Count > 0)
				mesh.normalArray = normalList.ToArray();
			if (colorList.Count>0)
				mesh.colorArray = colorList.ToArray();
			//			if (uv.Count>0)
			//				mesh.uv = uv.ToArray();
			//			if (uv1.Count>0)
			//				mesh.uv1 = uv1.ToArray();
			//			if (uv2.Count>0)
			//				mesh.uv2 = uv2.ToArray();
			
			mesh.indexArray = indexList.ToArray();
			mesh.vertices = this.vertices;
			mesh.triangles = this.triangles;

			List<int> newVerts = newVectices.Values.ToList();
			List<int> newTriangles = mesh.getTrianglesFromVertices(newVerts);
			mesh.updateMesh(newTriangles, true);
			return newVerts;
		}


		public void Subdivide4Triangle(int iTri)
		{
			int idx = iTri * 3;
			int i1 = indexList[idx];
			int i2 = indexList[idx + 1];
			int i3 = indexList[idx + 2];

			Vertex v1 = vertices[i1];
			Vertex v2 = vertices[i2];
			Vertex v3 = vertices[i3];

			Triangle t = triangles[iTri];
			Octree leaf = t.leaf;


			int a = GetNewVertex4(i1, i2);
			Vertex vA = new Vertex(a);
			vA.ringVertices.Add(i1);
			vA.ringVertices.Add(i2);
			v1.replaceRingVertex(i2, a);
			v2.replaceRingVertex(i1, a);


			vertices.Add(vA);

			int b = GetNewVertex4(i2, i3);
			Vertex vB = new Vertex(b);
			vB.ringVertices.Add(i2);
			vB.ringVertices.Add(i3);
			v2.replaceRingVertex(i3, b);
			v3.replaceRingVertex(i2, b);
			vertices.Add(vB);

			int c = GetNewVertex4(i3, i1);
			Vertex vC = new Vertex(c);
			vC.ringVertices.Add(i3);
			vC.ringVertices.Add(i1);
			v3.replaceRingVertex(i1, c);
			v1.replaceRingVertex(i3, c);
			vertices.Add(vC);

			//draw new triangle
			Vector3 pA = mesh.transform.TransformPoint(vertexList[a]);
			Vector3 pB = mesh.transform.TransformPoint(vertexList[b]);
			Vector3 pC = mesh.transform.TransformPoint(vertexList[c]);

			Debug.DrawLine(pA, pB, Color.red, 3);
			Debug.DrawLine(pB, pC, Color.green, 3);
			Debug.DrawLine(pC, pA, Color.blue, 3);
			 

			//redirect old triangle: 
			indexList[idx] = i1;
			indexList[idx + 1] = a;
			indexList[idx + 2] = c;

			// add new rendering triangles
			indexList.Add(i2);   indexList.Add(b);   indexList.Add(a);
			indexList.Add(i3);   indexList.Add(c);   indexList.Add(b);
			indexList.Add(a);   indexList.Add(b);   indexList.Add(c); // center triangle


			// add new logical triangles

			Triangle t2 = new Triangle(triangles.Count);
			t2.leaf = leaf;
			triangles.Add(t2);
			leaf.iTris.Add(t2.id);


			Triangle t3 = new Triangle(triangles.Count);
			t3.leaf = leaf;
			triangles.Add(t3);
			leaf.iTris.Add(t3.id);

			Triangle t4 = new Triangle(triangles.Count);
			t4.leaf = leaf;
			triangles.Add(t4);
			leaf.iTris.Add(t4.id);

			// add new triangle to old
			v1.tIndices.Add(t4.id);
			v2.tIndices.Add(t4.id);
			v3.tIndices.Add(t4.id);

			// rederect old triangles:
			v2.replaceTriangle(iTri, t2.id);
			v3.replaceTriangle(iTri, t3.id);


			// add triangles to new vertices:

			//vertices[a].tIndices.AddRange( v1.tIndices.Intersect(v2.tIndices));
			vertices[a].tIndices.Add(t.id);
			vertices[a].tIndices.Add(t2.id);
			vertices[a].tIndices.Add(t4.id);


			//vertices[b].tIndices.AddRange( v2.tIndices.Intersect(v3.tIndices));
			vertices[b].tIndices.Add(t2.id);
			vertices[b].tIndices.Add(t3.id);
			vertices[b].tIndices.Add(t4.id);

			//vertices[c].tIndices.AddRange( v3.tIndices.Intersect(v1.tIndices));
			vertices[c].tIndices.Add(t3.id);
			vertices[c].tIndices.Add(t.id);
			vertices[c].tIndices.Add(t4.id);

		}

		int GetNewVertex4(int i1, int i2)
		{
			int newIndex = vertexList.Count;
			uint t1 = ((uint)i1 << 16) | (uint)i2;
			uint t2 = ((uint)i2 << 16) | (uint)i1;
			if (newVectices.ContainsKey(t2))
				return newVectices[t2];
			if (newVectices.ContainsKey(t1))
				return newVectices[t1];
			
			newVectices.Add(t1,newIndex);
			
			vertexList.Add((vertexList[i1] + vertexList[i2]) * 0.5f);
			if (normalList.Count>0)
				normalList.Add((normalList[i1] + normalList[i2]).normalized);
			if (colorList.Count>0)
				colorList.Add((colorList[i1] + colorList[i2]) * 0.5f);
//			if (uv.Count>0)
//				uv.Add((uv[i1] + uv[i2])*0.5f);
//			if (uv1.Count>0)
//				uv1.Add((uv1[i1] + uv1[i2])*0.5f);
//			if (uv2.Count>0)
//				uv2.Add((uv2[i1] + uv2[i2])*0.5f);
			
			return newIndex;
		}


		
		

	} // class
}// namespace




