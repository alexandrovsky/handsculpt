// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System.Collections.Generic;
using UnityEngine;
namespace Sculpt{
	public class Octree
	{
		public static int maxDepth = 8;
		public static int maxTriangles = 100;

		public Octree parent = null;
		public List<Octree> children = null;
		int depth = 0;
		public Bounds aabbLoose;
		public Bounds aabbSplit;
		public  List<int> iTris = null;
		
		public static List<Octree> selectedNodes = new List<Octree>();

		public Octree (Octree parent, int depth)
		{
			this.parent = parent;
			this.depth = 0;
			children = new List<Octree>();
			iTris = new List<int>();
			aabbLoose = new Bounds();
			aabbSplit = new Bounds();
		}

		public void build(SculptMesh mesh, List<int> iTris){

			this.iTris = iTris;
			int nbTriangles = this.iTris.Count;
			if(nbTriangles > Octree.maxTriangles && depth < Octree.maxDepth){
				constructCells(mesh);
			}else if(nbTriangles > 0){

				List<Triangle> triangles = mesh.triangles;

				float bxmin = Mathf.Infinity;
				float bymin = Mathf.Infinity;
				float bzmin = Mathf.Infinity;

				float bxmax = Mathf.NegativeInfinity;
				float bymax = Mathf.NegativeInfinity;
				float bzmax = Mathf.NegativeInfinity;


				for(int i = 0; i < nbTriangles; i++){
					Triangle t = triangles[iTris[i]];
					t.leaf = this;
					t.posInLeaf = i;

					Vector3 tMin = t.aabb.min;
					Vector3 tMax = t.aabb.max;
					if(tMax.x > bxmax) bxmax = tMax.x;
					if(tMin.x < bxmin) bxmin = tMin.x;

					if(tMax.y > bymax) bymax = tMax.y;
					if(tMin.y < bymin) bymin = tMin.y;

					if(tMax.z > bzmax) bzmax = tMax.z;
					if(tMin.z < bzmin) bzmin = tMin.z;

				}
				this.aabbLoose.SetMinMax(new Vector3 (bxmin, bymin, bzmin),
				                         new Vector3 (bxmax, bymax, bzmax) );

				Octree parent = this.parent;
				while(parent != null){
					parent.aabbLoose.Encapsulate(this.aabbLoose);
					parent = parent.parent;
				}

			}
		}

		private void constructCells(SculptMesh mesh){
			Vector3 min = this.aabbSplit.min;
			Vector3 max = this.aabbSplit.max;
			Vector3 dx = ( max - min ) * 0.5f;
			Vector3 cen = ( max + min ) * 0.5f;

			List<int> iTris0 = new List<int>();
			List<int> iTris1 = new List<int>();
			List<int> iTris2 = new List<int>();
			List<int> iTris3 = new List<int>();
			List<int> iTris4 = new List<int>();
			List<int> iTris5 = new List<int>();
			List<int> iTris6 = new List<int>();
			List<int> iTris7 = new List<int>();

			List<Triangle> triangles = mesh.triangles;

			for(int i = 0; i < iTris.Count; i++){
				int iTri = iTris[i];
				Triangle t = triangles[iTri];
				Vector3 tCenter = t.aabb.center;

				if(tCenter.x > cen.x){
					if(tCenter.y > cen.y){
						if(tCenter.z > cen.z){
							iTris6.Add(iTri);
						}
						else{
							iTris5.Add(iTri);
						}
					}else{
						if(tCenter.z > cen.z){
							iTris2.Add(iTri);
						}else{
							iTris1.Add(iTri);
						}
					}
				}else{
					if(tCenter.y > cen.y){
						if(tCenter.z > cen.z){
							iTris7.Add(iTri);
						}
						else{
							iTris4.Add(iTri);
						}
					}else{
						if(tCenter.z > cen.z){
							iTris3.Add(iTri);
						}else{
							iTris0.Add(iTri);
						}
					}
				}
			}

			int nextDepth = this.depth + 1;

			Octree child0 = new Octree(this, nextDepth);
			child0.aabbSplit.SetMinMax(min, cen);
			child0.build(mesh, iTris0);

			Octree child1 = new Octree(this, nextDepth);
			child1.aabbSplit.SetMinMax(new Vector3(min.x + dx.x, min.y, min.z),
			                           new Vector3(cen.x + dx.x, cen.y, cen.z) );
			child1.build(mesh, iTris1);

			Octree child2 = new Octree(this, nextDepth);
			child2.aabbSplit.SetMinMax(new Vector3(cen.x, cen.y - dx.y, cen.z),
			                           new Vector3(max.x, max.y - dx.y, max.z) );
			child2.build(mesh, iTris2);


			Octree child3 = new Octree(this, nextDepth);
			child3.aabbSplit.SetMinMax(new Vector3(min.x, min.y, min.z + dx.z),
			                           new Vector3(cen.x, cen.y, cen.z + dx.z) );
			child3.build(mesh, iTris3);


			Octree child4 = new Octree(this, nextDepth);
			child4.aabbSplit.SetMinMax(new Vector3(min.x, min.y + dx.y, min.z),
			                           new Vector3(cen.x, cen.y + dx.y, cen.z) );
			child4.build(mesh, iTris4);

			Octree child5 = new Octree(this, nextDepth);
			child5.aabbSplit.SetMinMax(new Vector3(cen.x, cen.y, cen.z - dx.z),
			                           new Vector3(max.x, max.y, max.z - dx.z) );
			child5.build(mesh, iTris5);

			Octree child6 = new Octree(this, nextDepth);
			child6.aabbSplit.SetMinMax(new Vector3(cen.x, cen.y, cen.z),
			                           new Vector3(max.x, max.y, max.z) );
			child6.build(mesh, iTris6);

			Octree child7 = new Octree(this, nextDepth);
			child7.aabbSplit.SetMinMax(new Vector3(cen.x - dx.x, cen.y, cen.z),
			                           new Vector3(max.x - dx.x, max.y, max.z) );
			child7.build(mesh, iTris7);

			children.Add(child0);
			children.Add(child1);
			children.Add(child2);
			children.Add(child3);
			children.Add(child4);
			children.Add(child5);
			children.Add(child6);
			children.Add(child7);

		}

		public List<int> intersectRay(Ray ray){
			if(this.aabbLoose.IntersectRay(ray) ){
				Octree.selectedNodes.Add(this);
				if(this.children.Count == 8 ){
					List<int> iTriangles = new List<int>();
					foreach(Octree child in children){
						iTriangles.AddRange(child.intersectRay(ray) );
					}
					return iTriangles;
				}else{
					return iTris;
				}

			}else{
				return new List<int>();
			}
		}
	}
}



