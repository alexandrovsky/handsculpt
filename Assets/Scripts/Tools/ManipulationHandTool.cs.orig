// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using UnityEngine;
using System.Collections.Generic;
using Leap;



public abstract class ManipulationHandTool : HandTool
{

	protected TargetObjectScript tos;

	protected Mesh mesh = null;
	protected MeshFilter meshFilter;
	protected Vector3[] vertices = null;
	public Color[] colors = null;
	protected int[] triangles = null;
	public float minDistance = float.MaxValue;

	protected RaycastHit handhit;
	protected Dictionary<int, float> selectedVertices;



	public Octree octree = null;

	public bool debugGizmos;
	public bool debugGizmoVertices;
	List<Node> visitedNodes;

	void OnDrawGizmos()
	{
		if(!debugGizmos) return; // OUT -->


		Gizmos.color = Color.yellow;
		//Gizmos.DrawWireCube(target.transform.position, target.transform.renderer.bounds.size);
		if(octree != null){
			if(debugGizmoVertices){
//				Octree.DrawTree(octree.root, target.transform, vertices);
				foreach (Node node in visitedNodes){
					Gizmos.DrawWireCube(node.bounds.center, node.bounds.size);
				}

			}else{
				Octree.DrawTree(octree.root);
//				Octree.DrawTree(octree);
			}
			//			
		}
	}


	public override void Start()
	{	
		Debug.Log("Manipulation tool started");
		base.Start();

		PullMeshData();
		selectedVertices = new Dictionary<int, float>();
		visitedNodes = new List<Node>();
		octree = tos.octree;
	}

	public void PullMeshData()
	{
		target = GameObject.Find("Target");

		tos = target.GetComponent<TargetObjectScript>();

		meshFilter =  target.GetComponent<MeshFilter>(); // tos.meshFilter;//
		mesh =  meshFilter.sharedMesh; // tos.mesh;

		vertices = mesh.vertices; // tos.vertices;// 
		colors = mesh.colors; // tos.colors; // 
		triangles = mesh.triangles; // tos.triangles; // 

	}

	public void PushMeshData(){
		
		mesh.vertices = vertices;
		mesh.colors = colors;
		mesh.triangles = triangles;
//		mesh.Optimize();

		meshFilter.sharedMesh = mesh;
	}

	#region SELECTION
	public void ClearSelection(){

		//Debug.Log("clear selection!!!");
//		for(int idx = 0; idx < colors.Length; idx++){
//			colors[idx] = Color.cyan; // CleanColor();
//		}

		foreach(int v_idx in selectedVertices.Keys){
			colors[v_idx] = CleanColor();
		}
		selectedVertices.Clear();
		visitedNodes.Clear();
		PushMeshData();
	}

	public float debugRecursionCount;
	public void SelectVertices(Bounds toolBounds){
		// get current meshdata:
		PullMeshData();

		// clear last selection:
		ClearSelection();
		debugRecursionCount = 0;
		minDistance = SelectVerticesRecursive(octree.root, toolBounds);



		PushMeshData();
	}

	private float SelectVerticesRecursive(Node root, Bounds toolBounds){
		debugRecursionCount++;
		bool contains =  true; //root.bounds.Intersects(toolBounds);
		float distance = Vector3.Distance(root.bounds.center, toolBounds.center);

		if(contains ) 
		{ //&& distance < toolBounds.extents.magnitude ){
			if(!root.isLeaf){
				for(int nodeIdx = 0; nodeIdx < root.children.Length; nodeIdx++){
					Node child = root.children[nodeIdx];
					if(child != null){
						SelectVerticesRecursive(child, toolBounds);
					}
					visitedNodes.Add(root);
				}
			}else{
				foreach(int v_idx in root.vertices){
					Vector3 vertex = target.transform.TransformPoint(vertices[v_idx]);

					float vDist = Vector3.Distance(toolBounds.center, vertex);
					if(vDist < toolBounds.size.magnitude){
						selectedVertices.Add(v_idx, vDist);
						colors[v_idx] = SelectionColor();
					}
				}
			}
		}
		return distance;
	}




#endregion

#region MANIPULATION
	public abstract void ManipulateVertices(RaycastHit hit, float radius);
	public abstract void ManipulateVertices (Bounds toolBounds, Transform transform);
#endregion

//	public Ray CalculateRay(Leap.Vector pos){
//		Leap.InteractionBox iBox = LeapInput.Frame.InteractionBox;
//		Leap.Vector normalizedPosition = iBox.NormalizePoint(pos);
//		Vector3 screenPos = new Vector3(UnityEngine.Screen.width * normalizedPosition.x,
//		                                UnityEngine.Screen.height * normalizedPosition.y,
//		                                0.0f);
//		ray = Camera.main.ScreenPointToRay (screenPos);
//		return ray;
//	}

	public static Color CleanColor(){
		return Color.white;
	}

	public static Color SelectionColor(){
		return Color.yellow;
	}

	public static Color ManipulationColor(){
		return Color.red;
	}



}

